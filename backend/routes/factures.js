const express = require('express');
const router = express.Router();
const { getSequelize } = require('../config/db.config');
const { authenticate, optionalAuth } = require('../middleware/auth');
const { Op } = require('sequelize');
const { logActivity } = require('../middleware/activity-logger');

// Fonction helper pour obtenir les mod√®les
const getModels = () => {
  const sequelize = getSequelize();
  return {
    Facture: sequelize.models.Facture,
    Client: sequelize.models.Client
  };
};

// üî¥ FONCTION POUR D√âTECTER LES FACTURES EN RETARD
const estFactureEnRetard = (facture) => {
  // Une facture est en retard si :
  // 1. Elle n'est pas pay√©e (statut diff√©rent de 'payee')
  // 2. Sa date d'√©ch√©ance est d√©pass√©e de plus de 30 jours
  if (facture.statut?.toLowerCase() === 'payee' || facture.statut?.toLowerCase() === 'annulee') {
    return false;
  }
  
  if (!facture.dateEcheance) {
    return false;
  }
  
  const dateEcheance = new Date(facture.dateEcheance);
  const maintenant = new Date();
  const diffEnJours = Math.floor((maintenant - dateEcheance) / (1000 * 60 * 60 * 24));
  
  return diffEnJours > 30;
};

// GET /api/factures - R√©cup√©rer toutes les factures (avec filtrage par utilisateur)
router.get('/', optionalAuth, async (req, res) => {
  try {
    const { Facture, Client } = getModels();
    const user = req.user;
    
    if (!Facture) {
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    console.log('üë§ Utilisateur connect√© (factures):', user ? `${user.nom} ${user.prenom} (${user.role})` : 'Non authentifi√©');
    console.log('üìä R√©cup√©ration des factures...');
    
    // Construire les conditions de filtrage selon le r√¥le
    let whereConditions = {};
    
    if (user && user.role === 'conseillere') {
      // Les conseill√®res ne voient que leurs propres factures
      const fullName1 = `${user.prenom} ${user.nom}`; // Format pr√©nom nom
      const fullName2 = `${user.nom} ${user.prenom}`; // Format nom pr√©nom
      const nickName = `${user.prenom} ${user.nom.charAt(0)}.`; // Format Marie T.
      
      whereConditions = {
        [Op.or]: [
          { validePar: fullName1 },
          { validePar: fullName1.toLowerCase() },
          { validePar: fullName2 },
          { validePar: fullName2.toLowerCase() },
          { validePar: nickName },
          { validePar: nickName.toLowerCase() },
          { validePar: user.prenom }, // Juste le pr√©nom
          { validePar: user.nom }     // Juste le nom
        ]
      };
      console.log('üîí Filtrage factures pour conseill√®re:', fullName1, 'ou', fullName2, 'ou', nickName);
    }
    // Les admins, directeurs, secr√©taires et comptables voient toutes les factures (pas de filtre)
    
    // R√©cup√©rer les factures avec filtrage
    const factures = await Facture.findAll({
      where: whereConditions,
      include: [
        {
          model: Client,
          as: 'clientInfo',
          attributes: ['id', 'nom', 'prenom', 'email', 'type_procedure'],
          required: false
        }
      ],
      order: [['createdAt', 'DESC']]
    });
    
    // Transformer les donn√©es pour le frontend
    const facturesFormatted = factures.map(facture => {
      const factureFormatted = {
        id: facture.id,
        numero: facture.numero_facture || facture.numero,
        client: facture.client,
        client_id: facture.client_id,
        montant: facture.montant || 0,
        monnaie: facture.monnaie || 'MAD',
        statut: facture.statut,
        dateEmission: facture.date_creation ? facture.date_creation.toISOString().split('T')[0] : facture.dateEmission,
        dateEcheance: facture.dateEcheance ? facture.dateEcheance.toISOString().split('T')[0] : null,
        datePaiement: facture.datePaiement ? facture.datePaiement.toISOString().split('T')[0] : null,
        methodePaiement: facture.methodePaiement,
        description: facture.description || `Facture automatique - ${facture.clientInfo?.type_procedure || 'Service'}`,
        prestations_details: facture.prestations_details
      };
      
      // üî¥ AJOUTER LA PROPRI√âT√â EN_RETARD CALCUL√âE
      factureFormatted.en_retard = estFactureEnRetard(factureFormatted);
      
      return factureFormatted;
    });
    
    console.log(`‚úÖ ${factures.length} factures r√©cup√©r√©es`);
    
    res.json({
      success: true,
      message: `${factures.length} factures r√©cup√©r√©es`,
      data: facturesFormatted,
      filteredBy: user && user.role === 'conseillere' ? `${user.nom} ${user.prenom}` : 'Toutes'
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des factures:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des factures',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

// GET /api/factures/:id - R√©cup√©rer une facture par ID
router.get('/:id', optionalAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const { Facture, Client } = getModels();
    
    if (!Facture) {
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    // Construire les conditions de recherche selon le r√¥le
    let whereConditions = { id: id };
    const user = req.user;
    
    if (user && user.role === 'conseillere') {
      // Les conseill√®res ne peuvent voir que leurs propres factures
      const fullName1 = `${user.prenom} ${user.nom}`;
      const fullName2 = `${user.nom} ${user.prenom}`;
      const nickName = `${user.prenom} ${user.nom.charAt(0)}.`;
      
      whereConditions = {
        id: id,
        [Op.or]: [
          { validePar: fullName1 },
          { validePar: fullName1.toLowerCase() },
          { validePar: fullName2 },
          { validePar: fullName2.toLowerCase() },
          { validePar: nickName },
          { validePar: nickName.toLowerCase() },
          { validePar: user.prenom },
          { validePar: user.nom }
        ]
      };
    }
    
    const facture = await Facture.findOne({
      where: whereConditions,
      include: [
        {
          model: Client,
          as: 'clientInfo',
          attributes: ['id', 'nom', 'prenom', 'email', 'type_procedure'],
          required: false
        }
      ]
    });
    
    if (!facture) {
      return res.status(404).json({
        success: false,
        message: 'Facture non trouv√©e ou acc√®s non autoris√©'
      });
    }
    
    // Transformer les donn√©es pour le frontend
    const factureFormatted = {
      id: facture.id,
      numero: facture.numero_facture || facture.numero,
      client: facture.client,
      client_id: facture.client_id,
      montant: facture.montant || 0,
      statut: facture.statut,
      dateEmission: facture.date_creation ? facture.date_creation.toISOString().split('T')[0] : facture.dateEmission,
      dateEcheance: facture.dateEcheance ? facture.dateEcheance.toISOString().split('T')[0] : null,
      datePaiement: facture.datePaiement ? facture.datePaiement.toISOString().split('T')[0] : null,
      methodePaiement: facture.methodePaiement,
      description: facture.description || `Facture automatique - ${facture.clientInfo?.type_procedure || 'Service'}`,
      prestations_details: facture.prestations_details
    };
    
    res.json({
      success: true,
      message: 'Facture r√©cup√©r√©e avec succ√®s',
      data: factureFormatted
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration de la facture:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration de la facture',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

// PUT /api/factures/:id - Mettre √† jour une facture
router.put('/:id', optionalAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;
    console.log(`üìù Mise √† jour facture ${id} avec donn√©es:`, updateData);
    
    const { Facture } = getModels();
    
    if (!Facture) {
      console.error('‚ùå Mod√®le Facture non disponible');
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    // Construire les conditions de recherche selon le r√¥le
    let whereConditions = { id: id };
    const user = req.user;
    
    if (user && user.role === 'conseillere') {
      // Les conseill√®res ne peuvent modifier que leurs propres factures
      const fullName1 = `${user.prenom} ${user.nom}`;
      const fullName2 = `${user.nom} ${user.prenom}`;
      const nickName = `${user.prenom} ${user.nom.charAt(0)}.`;
      
      whereConditions = {
        id: id,
        [Op.or]: [
          { validePar: fullName1 },
          { validePar: fullName1.toLowerCase() },
          { validePar: fullName2 },
          { validePar: fullName2.toLowerCase() },
          { validePar: nickName },
          { validePar: nickName.toLowerCase() },
          { validePar: user.prenom },
          { validePar: user.nom }
        ]
      };
    }
    
    const facture = await Facture.findOne({ where: whereConditions });
    console.log(`üîç Facture trouv√©e:`, facture ? `ID ${facture.id}, statut: ${facture.statut}` : 'Non trouv√©e');
    
    if (!facture) {
      return res.status(404).json({
        success: false,
        message: 'Facture non trouv√©e ou acc√®s non autoris√©'
      });
    }
    
    // V√©rifier si la facture peut √™tre modifi√©e
    if (facture.statut === 'payee' && updateData.statut !== 'payee') {
      // Seuls les administrateurs peuvent annuler une facture pay√©e
      if (updateData.statut === 'annulee' && user && user.role === 'admin') {
        console.log(`üîí Administrateur ${user.prenom} ${user.nom} annule la facture pay√©e ${facture.numero_facture}`);
        // Ajouter des m√©tadonn√©es sur l'annulation
        updateData.annule_par = `${user.prenom} ${user.nom}`;
        updateData.date_annulation = new Date();
        updateData.raison_annulation = updateData.raison_annulation || 'Annulation administrative';
      } else {
        console.warn(`‚ö†Ô∏è Tentative de modification d'une facture pay√©e par ${user ? user.role : 'utilisateur non authentifi√©'}`);
        return res.status(403).json({
          success: false,
          message: 'Seul un administrateur peut annuler une facture pay√©e'
        });
      }
    }
    
    // Sauvegarder les anciennes valeurs pour le log
    const anciennesValeurs = {
      statut: facture.statut,
      montant: facture.montant,
      dateEcheance: facture.dateEcheance,
      datePaiement: facture.datePaiement,
      methodePaiement: facture.methodePaiement,
      numero: facture.numero_facture,
      client: facture.client
    };
    
    // Mettre √† jour la facture
    console.log(`üîÑ Mise √† jour en cours...`);
    await facture.update(updateData);
    
    // Enregistrer l'activit√© de mise √† jour
    if (user && user.id) {
      await logActivity(
        'update_facture',
        'Facture',
        facture.id,
        anciennesValeurs,
        {
          statut: facture.statut,
          montant: facture.montant,
          dateEcheance: facture.dateEcheance,
          datePaiement: facture.datePaiement,
          methodePaiement: facture.methodePaiement,
          ...updateData
        },
        req
      );
      
      console.log(`üìã Log d'activit√© cr√©√© pour la mise √† jour de la facture ${facture.id}`);
    }
    
    console.log(`‚úÖ Facture ${id} mise √† jour`);
    
    // üî¥ NOUVEAU : √âmettre un √©v√©nement socket.io pour rafra√Æchir le dashboard en temps r√©el
    try {
      const { getIO } = require('../socket');
      const io = getIO();
      io.emit('factureUpdated', {
        facture: facture,
        conseillere: facture.validePar,
        action: 'update',
        changes: updateData
      });
      console.log('üì° √âv√©nement socket.io √©mis : factureUpdated');
    } catch (socketError) {
      console.warn('‚ö†Ô∏è Erreur √©mission socket.io:', socketError.message);
      // Ne pas faire √©chouer la mise √† jour si socket.io √©choue
    }
    
    res.json({
      success: true,
      message: 'Facture mise √† jour avec succ√®s',
      data: facture
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la mise √† jour de la facture:', error);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour de la facture',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

// GET /api/factures/stats - Obtenir les statistiques des factures
router.get('/stats', optionalAuth, async (req, res) => {
  try {
    const { Facture } = getModels();
    
    if (!Facture) {
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    // Construire les conditions de filtrage selon le r√¥le
    let whereConditions = {};
    const user = req.user;
    
    if (user && user.role === 'conseillere') {
      // Les conseill√®res ne voient que leurs statistiques
      const fullName1 = `${user.prenom} ${user.nom}`;
      const fullName2 = `${user.nom} ${user.prenom}`;
      const nickName = `${user.prenom} ${user.nom.charAt(0)}.`;
      
      whereConditions = {
        [Op.or]: [
          { validePar: fullName1 },
          { validePar: fullName1.toLowerCase() },
          { validePar: fullName2 },
          { validePar: fullName2.toLowerCase() },
          { validePar: nickName },
          { validePar: nickName.toLowerCase() },
          { validePar: user.prenom },
          { validePar: user.nom }
        ]
      };
    }
    
    const factures = await Facture.findAll({ where: whereConditions });
    
    const stats = {
      totalFactures: factures.length,
      totalMontant: factures.reduce((sum, f) => sum + (f.montant || 0), 0),
      facturesPayees: factures.filter(f => f.statut === 'payee').length,
      facturesEnAttente: factures.filter(f => f.statut === 'brouillon' || f.statut === 'payable').length,
      facturesEnRetard: factures.filter(f => f.statut === 'en_retard').length
    };
    
    res.json({
      success: true,
      message: 'Statistiques r√©cup√©r√©es avec succ√®s',
      data: stats
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des statistiques:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des statistiques',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

// POST /api/factures - Cr√©er une nouvelle facture
router.post('/', authenticate, async (req, res) => {
  try {
    const { Facture, Client } = getModels();
    const user = req.user;
    
    if (!Facture) {
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    console.log('üë§ Utilisateur connect√© (cr√©ation facture):', user ? `${user.nom} ${user.prenom} (${user.role})` : 'Non authentifi√©');
    console.log('üìù Donn√©es de cr√©ation de facture:', req.body);
    
    const { 
      client_id, 
      montant, 
      monnaie = 'MAD', // Valeur par d√©faut MAD
      description, 
      dateEmission, 
      dateEcheance,
      statut = 'brouillon'
    } = req.body;
    
    // Validation des donn√©es requises
    if (!client_id || !montant || !description) {
      return res.status(400).json({
        success: false,
        message: 'Les champs client_id, montant et description sont obligatoires'
      });
    }
    
    // Validation de la monnaie
    if (monnaie && !['CAD', 'MAD'].includes(monnaie)) {
      return res.status(400).json({
        success: false,
        message: 'La monnaie doit √™tre CAD ou MAD'
      });
    }
    
    // V√©rifier que le client existe
    const client = await Client.findByPk(client_id);
    if (!client) {
      return res.status(404).json({
        success: false,
        message: 'Client non trouv√©'
      });
    }
    
    // D√©terminer quelle conseillere associer √† la facture
    let conseillereFacture = `${user.prenom} ${user.nom}`.trim();
    
    // Si le client n'a pas de conseill√®re assign√©e, l'assigner √† l'utilisateur actuel
    if (!client.conseillere && user.role === 'conseillere') {
      console.log(`üîÑ Attribution du client ${client.prenom} ${client.nom} √† ${conseillereFacture}`);
      await client.update({ conseillere: conseillereFacture });
    }
    
    // G√©n√©rer un num√©ro de facture unique
    const currentYear = new Date().getFullYear();
    const facturesCount = await Facture.count({
      where: {
        createdAt: {
          [Op.gte]: new Date(currentYear, 0, 1),
          [Op.lt]: new Date(currentYear + 1, 0, 1)
        }
      }
    });
    
    const numeroFacture = `F${currentYear}-${String(facturesCount + 1).padStart(3, '0')}`;
    
    // Cr√©er la facture avec l'association √† la conseill√®re
    const nouvelleFacture = await Facture.create({
      numero_facture: numeroFacture,
      client_id: client_id,
      montant: parseFloat(montant),
      monnaie: monnaie,
      description: description,
      dateEmission: dateEmission || new Date(),
      dateEcheance: dateEcheance || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 jours par d√©faut
      statut: statut,
      created_by: user.id,
      // üî¥ NOUVEAU : Associer la facture √† la conseill√®re qui la cr√©e
      validePar: conseillereFacture,
      dateValidation: new Date(),
      // Ancien syst√®me (pour compatibilit√©)
      numero: numeroFacture,
      client: `${client.nom} ${client.prenom}`.trim()
    });
    
    // R√©cup√©rer la facture cr√©√©e avec les informations du client
    const factureComplete = await Facture.findByPk(nouvelleFacture.id, {
      include: [{
        model: Client,
        as: 'clientInfo',
        attributes: ['id', 'nom', 'prenom', 'email', 'telephone']
      }]
    });
    
    // Enregistrer l'activit√© de cr√©ation
    await logActivity(
      'create_facture',
      'Facture',
      nouvelleFacture.id,
      null,
      {
        numero_facture: nouvelleFacture.numero_facture,
        client: `${client.nom} ${client.prenom}`.trim(),
        client_id: client_id,
        montant: parseFloat(montant),
        description: description,
        statut: statut,
        conseillere: conseillereFacture
      },
      req
    );
    
    console.log('‚úÖ Facture cr√©√©e avec succ√®s:', factureComplete.numero_facture);
    console.log(`üìã Log d'activit√© cr√©√© pour la cr√©ation de la facture ${nouvelleFacture.id}`);
    
    // üî¥ NOUVEAU : √âmettre un √©v√©nement socket.io pour rafra√Æchir le dashboard en temps r√©el
    try {
      const { getIO } = require('../socket');
      const io = getIO();
      io.emit('factureCreated', {
        facture: factureComplete,
        conseillere: conseillereFacture,
        action: 'create'
      });
      console.log('üì° √âv√©nement socket.io √©mis : factureCreated');
    } catch (socketError) {
      console.warn('‚ö†Ô∏è Erreur √©mission socket.io:', socketError.message);
      // Ne pas faire √©chouer la cr√©ation de facture si socket.io √©choue
    }
    
    res.status(201).json({
      success: true,
      message: 'Facture cr√©√©e avec succ√®s',
      data: factureComplete
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de la facture:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la cr√©ation de la facture',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

// POST /api/factures/:id/annuler - Annuler une facture (admin seulement)
router.post('/:id/annuler', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    const { raison_annulation } = req.body;
    const user = req.user;
    
    // V√©rifier que l'utilisateur est administrateur
    if (!user || user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Seul un administrateur peut annuler une facture'
      });
    }
    
    console.log(`üîí Tentative d'annulation de la facture ${id} par ${user.prenom} ${user.nom} (admin)`);
    
    const { Facture } = getModels();
    
    if (!Facture) {
      return res.status(503).json({
        success: false,
        message: 'Service de facturation non disponible'
      });
    }
    
    // R√©cup√©rer la facture
    const facture = await Facture.findByPk(id);
    
    if (!facture) {
      return res.status(404).json({
        success: false,
        message: 'Facture non trouv√©e'
      });
    }
    
    // V√©rifier si la facture peut √™tre annul√©e
    if (facture.statut === 'annulee') {
      return res.status(400).json({
        success: false,
        message: 'Cette facture est d√©j√† annul√©e'
      });
    }
    
    // Sauvegarder l'ancien statut pour le log
    const ancienStatut = facture.statut;
    
    // Annuler la facture
    await facture.update({
      statut: 'annulee',
      annule_par: `${user.prenom} ${user.nom}`,
      date_annulation: new Date(),
      raison_annulation: raison_annulation || 'Annulation administrative'
    });
    
    // Enregistrer l'activit√© d'annulation
    await logActivity(
      'cancel_facture',
      'Facture',
      facture.id,
      { 
        statut: ancienStatut,
        numero: facture.numero_facture,
        client: facture.client,
        montant: facture.montant
      },
      { 
        statut: 'annulee',
        annule_par: `${user.prenom} ${user.nom}`,
        date_annulation: new Date(),
        raison_annulation: raison_annulation || 'Annulation administrative'
      },
      req
    );
    
    console.log(`‚úÖ Facture ${facture.numero_facture} annul√©e par ${user.prenom} ${user.nom}`);
    console.log(`üìã Log d'activit√© cr√©√© pour l'annulation de la facture ${facture.id}`);
    
    res.json({
      success: true,
      message: 'Facture annul√©e avec succ√®s',
      data: facture
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'annulation de la facture:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'annulation de la facture',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Une erreur est survenue'
    });
  }
});

module.exports = router;